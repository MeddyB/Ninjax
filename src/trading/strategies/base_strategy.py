"""
Base strategy class providing common functionality for all trading strategies.
"""

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Union
from datetime import datetime
from enum import Enum


class SignalType(Enum):
    """Types of trading signals."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    STRONG_BUY = "strong_buy"
    STRONG_SELL = "strong_sell"


class StrategyState(Enum):
    """Strategy execution states."""
    INACTIVE = "inactive"
    ACTIVE = "active"
    PAUSED = "paused"
    ERROR = "error"


@dataclass
class StrategyConfig:
    """Configuration for trading strategies."""
    name: str
    description: str
    timeframe: str = "1h"  # 1m, 5m, 15m, 1h, 4h, 1d
    
    # Risk parameters
    max_position_size: float = 1000.0
    stop_loss_percentage: float = 2.0
    take_profit_percentage: float = 4.0
    risk_per_trade: float = 1.0  # Percentage of capital to risk per trade
    
    # Strategy parameters
    lookback_period: int = 20
    confidence_threshold: float = 0.7
    
    # Custom parameters
    parameters: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert config to dictionary."""
        return {
            'name': self.name,
            'description': self.description,
            'timeframe': self.timeframe,
            'max_position_size': self.max_position_size,
            'stop_loss_percentage': self.stop_loss_percentage,
            'take_profit_percentage': self.take_profit_percentage,
            'risk_per_trade': self.risk_per_trade,
            'lookback_period': self.lookback_period,
            'confidence_threshold': self.confidence_threshold,
            'parameters': self.parameters
        }


@dataclass
class StrategySignal:
    """Trading signal generated by a strategy."""
    signal_type: SignalType
    confidence: float
    price: float
    timestamp: datetime
    
    # Optional signal details
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    position_size: Optional[float] = None
    reasoning: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            'signal_type': self.signal_type.value,
            'confidence': self.confidence,
            'price': self.price,
            'timestamp': self.timestamp.isoformat(),
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'position_size': self.position_size,
            'reasoning': self.reasoning,
            'metadata': self.metadata or {}
        }


@dataclass
class StrategyResult:
    """Result of strategy analysis."""
    signals: List[StrategySignal]
    indicators: Dict[str, Any]
    market_analysis: Dict[str, Any]
    timestamp: datetime
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert result to dictionary."""
        return {
            'signals': [signal.to_dict() for signal in self.signals],
            'indicators': self.indicators,
            'market_analysis': self.market_analysis,
            'timestamp': self.timestamp.isoformat()
        }


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    Provides common functionality including:
    - Market data processing
    - Signal generation and validation
    - Risk management calculations
    - Performance tracking
    """
    
    def __init__(self, config: StrategyConfig, logger: Optional[logging.Logger] = None):
        """
        Initialize the trading strategy.
        
        Args:
            config: Strategy configuration
            logger: Optional logger instance
        """
        self.config = config
        self.logger = logger or logging.getLogger(__name__)
        
        # Strategy state
        self._state = StrategyState.INACTIVE
        self._last_analysis: Optional[datetime] = None
        
        # Market data
        self._price_data: List[Dict[str, Any]] = []
        self._indicators: Dict[str, List[float]] = {}
        
        # Signal history
        self._signal_history: List[StrategySignal] = []
        self._performance_metrics: Dict[str, float] = {}
    
    async def initialize(self) -> bool:
        """
        Initialize the strategy.
        
        Returns:
            True if initialization successful, False otherwise
        """
        try:
            self.logger.info(f"Initializing strategy: {self.config.name}")
            
            # Initialize strategy-specific components
            if not await self._initialize_strategy():
                return False
            
            # Validate configuration
            if not self._validate_config():
                return False
            
            self._state = StrategyState.ACTIVE
            self.logger.info(f"Strategy {self.config.name} initialized successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to initialize strategy {self.config.name}: {e}")
            self._state = StrategyState.ERROR
            return False
    
    async def analyze(self, market_data: List[Dict[str, Any]]) -> StrategyResult:
        """
        Analyze market data and generate trading signals.
        
        Args:
            market_data: List of OHLCV data points
            
        Returns:
            StrategyResult containing signals and analysis
        """
        if self._state != StrategyState.ACTIVE:
            raise RuntimeError(f"Strategy {self.config.name} is not active")
        
        try:
            # Update market data
            self._update_market_data(market_data)
            
            # Calculate indicators
            indicators = await self._calculate_indicators()
            
            # Generate signals
            signals = await self._generate_signals(indicators)
            
            # Validate signals
            validated_signals = self._validate_signals(signals)
            
            # Perform market analysis
            market_analysis = await self._analyze_market_conditions()
            
            # Update signal history
            self._signal_history.extend(validated_signals)
            
            # Update last analysis time
            self._last_analysis = datetime.now()
            
            result = StrategyResult(
                signals=validated_signals,
                indicators=indicators,
                market_analysis=market_analysis,
                timestamp=self._last_analysis
            )
            
            self.logger.debug(f"Strategy analysis completed: {len(validated_signals)} signals generated")
            return result
            
        except Exception as e:
            self.logger.error(f"Error in strategy analysis: {e}")
            self._state = StrategyState.ERROR
            raise
    
    def get_current_signals(self) -> List[StrategySignal]:
        """
        Get current active signals.
        
        Returns:
            List of current signals
        """
        # Return signals from the last analysis
        if not self._signal_history:
            return []
        
        # Get signals from the last hour
        current_time = datetime.now()
        recent_signals = [
            signal for signal in self._signal_history
            if (current_time - signal.timestamp).total_seconds() < 3600
        ]
        
        return recent_signals
    
    def get_performance_metrics(self) -> Dict[str, float]:
        """
        Get strategy performance metrics.
        
        Returns:
            Dictionary with performance metrics
        """
        return self._performance_metrics.copy()
    
    def get_state(self) -> StrategyState:
        """Get current strategy state."""
        return self._state
    
    def pause(self):
        """Pause the strategy."""
        if self._state == StrategyState.ACTIVE:
            self._state = StrategyState.PAUSED
            self.logger.info(f"Strategy {self.config.name} paused")
    
    def resume(self):
        """Resume the strategy."""
        if self._state == StrategyState.PAUSED:
            self._state = StrategyState.ACTIVE
            self.logger.info(f"Strategy {self.config.name} resumed")
    
    def stop(self):
        """Stop the strategy."""
        self._state = StrategyState.INACTIVE
        self.logger.info(f"Strategy {self.config.name} stopped")
    
    @abstractmethod
    async def _initialize_strategy(self) -> bool:
        """
        Initialize strategy-specific components.
        
        Returns:
            True if initialization successful, False otherwise
        """
        pass
    
    @abstractmethod
    async def _calculate_indicators(self) -> Dict[str, Any]:
        """
        Calculate technical indicators.
        
        Returns:
            Dictionary with calculated indicators
        """
        pass
    
    @abstractmethod
    async def _generate_signals(self, indicators: Dict[str, Any]) -> List[StrategySignal]:
        """
        Generate trading signals based on indicators.
        
        Args:
            indicators: Calculated indicators
            
        Returns:
            List of generated signals
        """
        pass
    
    async def _analyze_market_conditions(self) -> Dict[str, Any]:
        """
        Analyze current market conditions.
        
        Returns:
            Dictionary with market analysis
        """
        if len(self._price_data) < 2:
            return {'trend': 'unknown', 'volatility': 0.0, 'volume_trend': 'unknown'}
        
        # Basic market analysis
        recent_prices = [candle['close'] for candle in self._price_data[-10:]]
        
        # Trend analysis
        if len(recent_prices) >= 2:
            trend = 'bullish' if recent_prices[-1] > recent_prices[0] else 'bearish'
        else:
            trend = 'unknown'
        
        # Volatility analysis (simplified)
        if len(recent_prices) >= 5:
            price_changes = [abs(recent_prices[i] - recent_prices[i-1]) / recent_prices[i-1] 
                           for i in range(1, len(recent_prices))]
            volatility = sum(price_changes) / len(price_changes)
        else:
            volatility = 0.0
        
        # Volume trend analysis
        recent_volumes = [candle.get('volume', 0) for candle in self._price_data[-5:]]
        if len(recent_volumes) >= 2:
            volume_trend = 'increasing' if recent_volumes[-1] > recent_volumes[0] else 'decreasing'
        else:
            volume_trend = 'unknown'
        
        return {
            'trend': trend,
            'volatility': volatility,
            'volume_trend': volume_trend,
            'price_change_24h': (recent_prices[-1] - recent_prices[0]) / recent_prices[0] if len(recent_prices) >= 2 else 0.0
        }
    
    def _update_market_data(self, market_data: List[Dict[str, Any]]):
        """
        Update internal market data.
        
        Args:
            market_data: New market data to add
        """
        self._price_data.extend(market_data)
        
        # Keep only the required lookback period
        max_length = self.config.lookback_period * 2  # Keep extra for calculations
        if len(self._price_data) > max_length:
            self._price_data = self._price_data[-max_length:]
    
    def _validate_config(self) -> bool:
        """
        Validate strategy configuration.
        
        Returns:
            True if valid, False otherwise
        """
        if self.config.confidence_threshold < 0 or self.config.confidence_threshold > 1:
            self.logger.error("Confidence threshold must be between 0 and 1")
            return False
        
        if self.config.lookback_period <= 0:
            self.logger.error("Lookback period must be positive")
            return False
        
        if self.config.risk_per_trade <= 0 or self.config.risk_per_trade > 100:
            self.logger.error("Risk per trade must be between 0 and 100")
            return False
        
        return True
    
    def _validate_signals(self, signals: List[StrategySignal]) -> List[StrategySignal]:
        """
        Validate and filter generated signals.
        
        Args:
            signals: Raw signals to validate
            
        Returns:
            List of validated signals
        """
        validated_signals = []
        
        for signal in signals:
            # Check confidence threshold
            if signal.confidence < self.config.confidence_threshold:
                continue
            
            # Check signal type validity
            if signal.signal_type not in [SignalType.BUY, SignalType.SELL, SignalType.STRONG_BUY, SignalType.STRONG_SELL]:
                continue
            
            # Calculate position size if not provided
            if signal.position_size is None:
                signal.position_size = self._calculate_position_size(signal)
            
            # Calculate stop loss and take profit if not provided
            if signal.stop_loss is None:
                signal.stop_loss = self._calculate_stop_loss(signal)
            
            if signal.take_profit is None:
                signal.take_profit = self._calculate_take_profit(signal)
            
            validated_signals.append(signal)
        
        return validated_signals
    
    def _calculate_position_size(self, signal: StrategySignal) -> float:
        """
        Calculate position size based on risk management.
        
        Args:
            signal: Trading signal
            
        Returns:
            Calculated position size
        """
        # Simple position sizing based on risk per trade
        risk_amount = self.config.max_position_size * (self.config.risk_per_trade / 100)
        
        if signal.stop_loss:
            risk_per_unit = abs(signal.price - signal.stop_loss)
            if risk_per_unit > 0:
                position_size = risk_amount / risk_per_unit
                return min(position_size, self.config.max_position_size)
        
        # Default to 10% of max position size
        return self.config.max_position_size * 0.1
    
    def _calculate_stop_loss(self, signal: StrategySignal) -> float:
        """
        Calculate stop loss price.
        
        Args:
            signal: Trading signal
            
        Returns:
            Stop loss price
        """
        if signal.signal_type in [SignalType.BUY, SignalType.STRONG_BUY]:
            return signal.price * (1 - self.config.stop_loss_percentage / 100)
        else:
            return signal.price * (1 + self.config.stop_loss_percentage / 100)
    
    def _calculate_take_profit(self, signal: StrategySignal) -> float:
        """
        Calculate take profit price.
        
        Args:
            signal: Trading signal
            
        Returns:
            Take profit price
        """
        if signal.signal_type in [SignalType.BUY, SignalType.STRONG_BUY]:
            return signal.price * (1 + self.config.take_profit_percentage / 100)
        else:
            return signal.price * (1 - self.config.take_profit_percentage / 100)
    
    def get_strategy_info(self) -> Dict[str, Any]:
        """
        Get strategy information.
        
        Returns:
            Dictionary with strategy details
        """
        return {
            'name': self.config.name,
            'description': self.config.description,
            'state': self._state.value,
            'timeframe': self.config.timeframe,
            'last_analysis': self._last_analysis.isoformat() if self._last_analysis else None,
            'signal_count': len(self._signal_history),
            'current_signals': len(self.get_current_signals()),
            'config': self.config.to_dict()
        }