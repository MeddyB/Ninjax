"""
Gestionnaire des Applications Web - Axiom Trade
G√®re le d√©marrage et l'arr√™t automatique des applications web
"""
import subprocess
import threading
import time
import logging
import sys
import os
from typing import Dict, Any, List, Optional
from datetime import datetime
from pathlib import Path

try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False

try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False

from ..core.config import Config
from ..core.exceptions import ServiceError
from ..data_models.service_model import ServiceStatus, ServiceState


class WebAppManager:
    """
    Gestionnaire des applications web Flask
    Responsable du d√©marrage/arr√™t automatique des applications web
    """
    
    def __init__(self, config: Config, logger: logging.Logger):
        self.config = config
        self.logger = logger
        self.processes = {}  # Dict[str, subprocess.Popen]
        self.app_configs = self._get_app_configurations()
        self.is_running = False
        self._monitor_thread = None
        self._stop_monitoring = False
        
        self.logger.info("WebAppManager initialis√©")
    
    def _get_app_configurations(self) -> Dict[str, Dict[str, Any]]:
        """Configuration des applications web"""
        return {
            'trading_dashboard': {
                'name': 'Trading Dashboard',
                'module': 'src.web_apps.trading_dashboard.app',
                'port': self.config.get('TRADING_DASHBOARD_PORT', 5001),
                'enabled': self.config.get('TRADING_DASHBOARD_ENABLED', True),
                'startup_delay': 2  # D√©lai en secondes avant d√©marrage
            },
            'backtesting_app': {
                'name': 'Backtesting App',
                'module': 'src.web_apps.backtesting_app.app',
                'port': self.config.get('BACKTESTING_APP_PORT', 5002),
                'enabled': self.config.get('BACKTESTING_APP_ENABLED', True),
                'startup_delay': 4
            },
            'ai_insights_app': {
                'name': 'AI Insights App',
                'module': 'src.web_apps.ai_insights_app.app',
                'port': self.config.get('AI_INSIGHTS_APP_PORT', 5003),
                'enabled': self.config.get('AI_INSIGHTS_APP_ENABLED', True),
                'startup_delay': 6
            }
        }
    
    def start_all_apps(self) -> bool:
        """
        D√©marre toutes les applications web activ√©es
        
        Returns:
            bool: True si toutes les applications ont d√©marr√© avec succ√®s
        """
        if self.is_running:
            self.logger.warning("Applications web d√©j√† en cours d'ex√©cution")
            return True
        
        self.logger.info("üöÄ D√©marrage des applications web...")
        
        success_count = 0
        total_enabled = sum(1 for app in self.app_configs.values() if app['enabled'])
        
        for app_id, app_config in self.app_configs.items():
            if not app_config['enabled']:
                self.logger.info(f"‚è≠Ô∏è {app_config['name']} d√©sactiv√©e, ignor√©e")
                continue
            
            try:
                # D√©lai de d√©marrage √©chelonn√©
                if app_config['startup_delay'] > 0:
                    self.logger.info(f"‚è≥ Attente {app_config['startup_delay']}s avant d√©marrage de {app_config['name']}")
                    time.sleep(app_config['startup_delay'])
                
                if self._start_single_app(app_id, app_config):
                    success_count += 1
                    self.logger.info(f"‚úÖ {app_config['name']} d√©marr√©e avec succ√®s")
                else:
                    self.logger.error(f"‚ùå √âchec d√©marrage {app_config['name']}")
                    
            except Exception as e:
                self.logger.error(f"‚ùå Erreur d√©marrage {app_config['name']}: {e}")
        
        self.is_running = success_count > 0
        
        if self.is_running:
            self._start_monitoring()
            self.logger.info(f"üéâ Applications web d√©marr√©es: {success_count}/{total_enabled}")
        else:
            self.logger.error("‚ùå Aucune application web n'a pu d√©marrer")
        
        return success_count == total_enabled
    
    def _start_single_app(self, app_id: str, app_config: Dict[str, Any]) -> bool:
        """
        D√©marre une application web sp√©cifique
        
        Args:
            app_id: Identifiant de l'application
            app_config: Configuration de l'application
            
        Returns:
            bool: True si l'application a d√©marr√© avec succ√®s
        """
        try:
            # V√©rifier si le port est libre
            if self._is_port_in_use(app_config['port']):
                self.logger.warning(f"‚ö†Ô∏è Port {app_config['port']} d√©j√† utilis√© pour {app_config['name']}")
                return False
            
            # Construire la commande
            python_exe = sys.executable
            module_path = app_config['module']
            
            # Variables d'environnement
            env = os.environ.copy()
            env.update({
                'FLASK_ENV': self.config.get('ENVIRONMENT', 'production'),
                'FLASK_DEBUG': str(self.config.get('FLASK_DEBUG', False)).lower(),
                f"{app_id.upper()}_PORT": str(app_config['port'])
            })
            
            # D√©marrer le processus
            self.logger.info(f"üîß D√©marrage {app_config['name']} sur port {app_config['port']}")
            
            process = subprocess.Popen(
                [python_exe, '-m', module_path],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                env=env,
                cwd=Path(__file__).parent.parent.parent,  # Racine du projet
                creationflags=subprocess.CREATE_NEW_PROCESS_GROUP
            )
            
            # Attendre un peu pour v√©rifier que le processus d√©marre
            time.sleep(2)
            
            if process.poll() is None:  # Processus toujours en cours
                self.processes[app_id] = process
                
                # V√©rifier que l'application r√©pond
                if self._wait_for_app_ready(app_config['port'], timeout=30):
                    self.logger.info(f"‚úÖ {app_config['name']} pr√™te sur http://localhost:{app_config['port']}")
                    return True
                else:
                    self.logger.error(f"‚ùå {app_config['name']} ne r√©pond pas apr√®s 30s")
                    self._stop_single_app(app_id)
                    return False
            else:
                # Processus s'est arr√™t√© imm√©diatement
                stdout, stderr = process.communicate()
                self.logger.error(f"‚ùå {app_config['name']} s'est arr√™t√©e imm√©diatement")
                self.logger.error(f"STDOUT: {stdout.decode()}")
                self.logger.error(f"STDERR: {stderr.decode()}")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Erreur d√©marrage {app_config['name']}: {e}")
            return False
    
    def _wait_for_app_ready(self, port: int, timeout: int = 30) -> bool:
        """
        Attend qu'une application soit pr√™te √† r√©pondre
        
        Args:
            port: Port de l'application
            timeout: Timeout en secondes
            
        Returns:
            bool: True si l'application r√©pond
        """
        if not REQUESTS_AVAILABLE:
            self.logger.warning("requests library not available, using socket check only")
            return not self._is_port_in_use(port)
        
        start_time = time.time()
        url = f"http://localhost:{port}/health"
        
        while time.time() - start_time < timeout:
            try:
                response = requests.get(url, timeout=2)
                if response.status_code == 200:
                    return True
            except requests.exceptions.RequestException:
                pass
            
            time.sleep(1)
        
        return False
    
    def _is_port_in_use(self, port: int) -> bool:
        """
        V√©rifie si un port est d√©j√† utilis√©
        
        Args:
            port: Port √† v√©rifier
            
        Returns:
            bool: True si le port est utilis√©
        """
        try:
            import socket
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(1)
                result = s.connect_ex(('localhost', port))
                return result == 0
        except Exception:
            return False
    
    def stop_all_apps(self) -> bool:
        """
        Arr√™te toutes les applications web
        
        Returns:
            bool: True si toutes les applications ont √©t√© arr√™t√©es
        """
        if not self.is_running:
            self.logger.info("Aucune application web en cours d'ex√©cution")
            return True
        
        self.logger.info("üõë Arr√™t des applications web...")
        
        # Arr√™ter le monitoring
        self._stop_monitoring = True
        if self._monitor_thread and self._monitor_thread.is_alive():
            self._monitor_thread.join(timeout=5)
        
        success_count = 0
        total_apps = len(self.processes)
        
        for app_id in list(self.processes.keys()):
            if self._stop_single_app(app_id):
                success_count += 1
        
        self.is_running = False
        self.logger.info(f"üèÅ Applications web arr√™t√©es: {success_count}/{total_apps}")
        
        return success_count == total_apps
    
    def _stop_single_app(self, app_id: str) -> bool:
        """
        Arr√™te une application web sp√©cifique
        
        Args:
            app_id: Identifiant de l'application
            
        Returns:
            bool: True si l'application a √©t√© arr√™t√©e avec succ√®s
        """
        if app_id not in self.processes:
            return True
        
        process = self.processes[app_id]
        app_name = self.app_configs[app_id]['name']
        
        try:
            self.logger.info(f"üõë Arr√™t de {app_name}...")
            
            # Tentative d'arr√™t gracieux
            process.terminate()
            
            # Attendre l'arr√™t gracieux
            try:
                process.wait(timeout=10)
                self.logger.info(f"‚úÖ {app_name} arr√™t√©e gracieusement")
            except subprocess.TimeoutExpired:
                # Forcer l'arr√™t si n√©cessaire
                self.logger.warning(f"‚ö†Ô∏è Arr√™t forc√© de {app_name}")
                process.kill()
                process.wait()
            
            # Nettoyer
            del self.processes[app_id]
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur arr√™t {app_name}: {e}")
            return False
    
    def _start_monitoring(self) -> None:
        """D√©marre le monitoring des applications web"""
        if self._monitor_thread and self._monitor_thread.is_alive():
            return
        
        self._stop_monitoring = False
        self._monitor_thread = threading.Thread(
            target=self._monitor_apps,
            name="WebAppsMonitor",
            daemon=True
        )
        self._monitor_thread.start()
        self.logger.info("üîç Monitoring des applications web d√©marr√©")
    
    def _monitor_apps(self) -> None:
        """
        Thread de monitoring des applications web
        Red√©marre automatiquement les applications qui s'arr√™tent
        """
        while not self._stop_monitoring:
            try:
                for app_id, process in list(self.processes.items()):
                    if process.poll() is not None:  # Processus arr√™t√©
                        app_config = self.app_configs[app_id]
                        self.logger.warning(f"‚ö†Ô∏è {app_config['name']} s'est arr√™t√©e, red√©marrage...")
                        
                        # Nettoyer le processus arr√™t√©
                        del self.processes[app_id]
                        
                        # Red√©marrer l'application
                        if self._start_single_app(app_id, app_config):
                            self.logger.info(f"‚úÖ {app_config['name']} red√©marr√©e avec succ√®s")
                        else:
                            self.logger.error(f"‚ùå √âchec red√©marrage {app_config['name']}")
                
                # Attendre avant la prochaine v√©rification
                time.sleep(30)  # V√©rification toutes les 30 secondes
                
            except Exception as e:
                self.logger.error(f"‚ùå Erreur monitoring applications web: {e}")
                time.sleep(60)  # Attendre plus longtemps en cas d'erreur
    
    def get_apps_status(self) -> Dict[str, Dict[str, Any]]:
        """
        Retourne le statut de toutes les applications web
        
        Returns:
            Dict contenant le statut de chaque application
        """
        status = {}
        
        for app_id, app_config in self.app_configs.items():
            app_status = {
                'name': app_config['name'],
                'port': app_config['port'],
                'enabled': app_config['enabled'],
                'running': False,
                'pid': None,
                'uptime': None,
                'url': f"http://localhost:{app_config['port']}"
            }
            
            if app_id in self.processes:
                process = self.processes[app_id]
                if process.poll() is None:  # Processus actif
                    app_status['running'] = True
                    app_status['pid'] = process.pid
                    
                    # Calculer l'uptime si possible
                    try:
                        if hasattr(process, 'create_time'):
                            uptime_seconds = time.time() - process.create_time()
                            app_status['uptime'] = f"{int(uptime_seconds // 3600)}h {int((uptime_seconds % 3600) // 60)}m"
                    except:
                        pass
            
            status[app_id] = app_status
        
        return status
    
    def restart_app(self, app_id: str) -> bool:
        """
        Red√©marre une application sp√©cifique
        
        Args:
            app_id: Identifiant de l'application
            
        Returns:
            bool: True si le red√©marrage a r√©ussi
        """
        if app_id not in self.app_configs:
            self.logger.error(f"‚ùå Application inconnue: {app_id}")
            return False
        
        app_config = self.app_configs[app_id]
        self.logger.info(f"üîÑ Red√©marrage de {app_config['name']}...")
        
        # Arr√™ter l'application si elle tourne
        if app_id in self.processes:
            self._stop_single_app(app_id)
            time.sleep(2)  # Attendre que le port se lib√®re
        
        # Red√©marrer l'application
        return self._start_single_app(app_id, app_config)
    
    def stop_app(self, app_id: str) -> bool:
        """
        Arr√™te une application sp√©cifique
        
        Args:
            app_id: Identifiant de l'application
            
        Returns:
            bool: True si l'arr√™t a r√©ussi
        """
        if app_id not in self.app_configs:
            self.logger.error(f"‚ùå Application inconnue: {app_id}")
            return False
        
        return self._stop_single_app(app_id)
    
    def start_app(self, app_id: str) -> bool:
        """
        D√©marre une application sp√©cifique
        
        Args:
            app_id: Identifiant de l'application
            
        Returns:
            bool: True si le d√©marrage a r√©ussi
        """
        if app_id not in self.app_configs:
            self.logger.error(f"‚ùå Application inconnue: {app_id}")
            return False
        
        app_config = self.app_configs[app_id]
        
        if not app_config['enabled']:
            self.logger.warning(f"‚ö†Ô∏è {app_config['name']} est d√©sactiv√©e")
            return False
        
        if app_id in self.processes and self.processes[app_id].poll() is None:
            self.logger.info(f"‚ÑπÔ∏è {app_config['name']} d√©j√† en cours d'ex√©cution")
            return True
        
        return self._start_single_app(app_id, app_config)
    
    def is_app_running(self, app_id: str) -> bool:
        """
        V√©rifie si une application est en cours d'ex√©cution
        
        Args:
            app_id: Identifiant de l'application
            
        Returns:
            bool: True si l'application tourne
        """
        if app_id not in self.processes:
            return False
        
        process = self.processes[app_id]
        return process.poll() is None
    
    def get_running_apps_count(self) -> int:
        """
        Retourne le nombre d'applications en cours d'ex√©cution
        
        Returns:
            int: Nombre d'applications actives
        """
        return sum(1 for app_id in self.processes.keys() if self.is_app_running(app_id))
    
    def cleanup(self) -> None:
        """Nettoie les ressources du gestionnaire"""
        self.logger.info("üßπ Nettoyage du WebAppManager...")
        self.stop_all_apps()